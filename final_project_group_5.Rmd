---
title: "A Bayesian Approach to Predicting NFL Quarterback Scores in Fanduel Tournaments"
author: 'STAT 578, Fall 2017, **Team 5**: Aaron Ray, Kiomars Nassiri, Michael Chan'
date: "October 25, 2017"
output:
  pdf_document:
  html_document:
    highlight: haddock
    theme: spacelab
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
options(scipen = 1, digits = 4, width = 80)
```

# Project Description

The National Football League (NFL), being one of the major professional sports leagues in North America, has a wide audience. participates in the NFL craze by competing in fantasy football tournaments organized by the daily fantasy site, "FanDuel.com". Participants in a **[Fantasy Football](https://en.wikipedia.org/wiki/Fantasy_football_(American))** game act as the managers of a virtual footbal team and try to maximize their points by picking up the best line-up. Points are given based on actual performance of players in real-world competition. 
For the purpose of this project we have chosen to work with the data gathered from the **[FanDuel](https://www.fanduel.com/)** internet company. We will leverage a Hierarchical Bayesian approach with the Markov Chain Monte Carlo method to predict the fantasy points likely to be scored by an NFL quarterback in any given game.  The goal is to predict the points scored by each player given certain prior conditions and predictor variables that will assist our model in providing credible posterior prediction intervals.

The analysis is inspired by the study presented in the article, **[Bayesian Hierarchical Modeling Applied to Fantasy Football Projections for Increased Insight and Confidence](http://srome.github.io/Bayesian-Hierarchical-Modeling-Applied-to-Fantasy-Football-Projections-for-Increased-Insight-and-Confidence/)**, by Scott Rome.

# Team Members

- **Aaron Ray** (aaronwr2@illinois.edu)$^*$
- **Kiomars Nassiri** (nassiri2@illinois.edu)
- **Michael Chan** (mhchan3@illinois.edu)

$^*$Contact Person

# Dataset Description

Team has set up a process to gather the historical data from the [RotoGuru](http://rotoguru1.com/cgi-bin/fstats.cgi?pos=0&sort=4&game=f&colA=0&daypt=0&xavg=0&inact=0&maxprc=99999&outcsv=0) website. The following is the code used to get the data from RotoGuru:

```{r, message=FALSE, warning=FALSE,eval=FALSE}
# Scrape rotoguru1 site for weekly FanDuel stats and bind each week's data to the 
# pre-defined dataframe, 'd'.

for(year in 2014:2017){
  for(week in 1:16){
    page = read_html(
      gsub(" ","",
           paste("http://rotoguru1.com/cgi-bin/fyday.pl?week=",week,"&year=",
                 year ,"&game=fd&scsv=1")
      ))
    dtext = page %>% html_nodes("pre") %>% html_text(trim = TRUE)
    dtable = read.table(text=dtext, sep = ";", header=TRUE, col.names = cnames,
                        quote=NULL)
    d = rbind(d,dtable)
  }
}
```

Data cleaning is performed using R routines. Some data cleaning tasks are needed to calculate Player rank.

## Response Variables

- `FanDuelPts`: Points position at the end of a single game

## Predictor Variables

- `6GmAvgOppPAP`: The six game average Opposing Points Allowed to Position (OppPAP) by the current player's opposing defense. For example, if the Buffalo Bills defense allowed a total of 30 points per game to wide receivers for six games straight, then this number would equal to the average of 30 for any wide receiver facing the Bills defense.
- `Position`: The position the player plays
- `Opponent`: The team that the player plays against
- `Rank`: The rank of a player based on recent performance

# Analysis Ideas

## Model




At the lowest level, we model the performance (`FanDuelPts`) as normally-distributed around a true value:

$y|\alpha, \beta_{defense}, \beta_{home}, \beta_{away}, \sigma_r^2 \sim N(\alpha + X_{defense} . \beta_{defense} + X_{home} . \beta_{home} + X_{away} . \beta_{away}, \sigma_y^2 I)$

where

$\alpha$ = `OffRnk5Wks`

$\beta_{defense,t,p}$ = defense coefficient against team t for position p

$\beta_{home,p,r}$ = home coefficient for position p and a rank r player

$\beta_{away,p,r}$ = Away coefficient for position p and a rank r player

$y$ = `FanDuelPts`

$x_{t,p}$ = interaction indicator term for team t, position p

$x_{p,r}$ = interaction indicator term for rank r, position p

At higher level, we model the defense effect, $\beta_{defense}$, as how good a player is when playing against a particular team.  We pool the effect based on the position of the player.  That is, the defense coefficient is normally distributed from the same position specific distribution.

$\beta_{defense,t,p} \sim N(\delta_p, \sigma_{\delta}^2)$

For the home and away game effect, $\beta_{home}$ and $\beta_{away}$, we model the effect for player of the same rank has the same distribution.

$\beta_{home,r} \sim N(\eta_r, \sigma_{\eta}^2)$

$\beta_{away,r} \sim N(\rho_r, \sigma_{\rho}^2)$

We will approximate non informative prior using:

$\sigma_y \sim Inv-gamma(0.0001, 0.0001)$

$\sigma_{\delta} \sim N(0, 100^2)$

$\sigma_{\eta} \sim N(0, 100^2)$

$\sigma_{\rho} \sim N(0, 100^2)$

Here is the JAGS model:

```{r}
#sink("fdp.bug")
#cat("
model {
  for (i in 1:length(y)) {
    y[i] ~ dnorm(alpha[i] + inprod(X.defense[i, ], beta.defense) 
                 + inprod(X.home[i, ], beta.home) 
                 + inprod(X.away[i, ], beta.away), sigmasqinv)
  }
  
  # The entry of the beta.defense corresponds to Opponent:Position
  # In our model, we pool the beta.defense based on position. 
  # i.e. All defense effects of the same position are drawn from the same distribution
  for (p in 1:Num.Position) {
    for (t in 1:Num.Opponent) {
      beta.defense[(p-1) * Num.Opponent + t] ~ dnorm(delta[p], 1/100^2)
    }
    delta[p] ~ dnorm(0, 1/100^2)
  }
  
  # The entry of the beta.home and beta.away corresponds to Rank:Position
  # In our model, we pool the beta.home/away based on rank
  for (r in 1:Num.Rank) {
    for (t in 1:Num.Position) {
      beta.home[(r-1) * Num.Position + t] ~ dnorm(eta[r], 1/100^2)
      beta.away[(r-1) * Num.Position + t] ~ dnorm(rho[r], 1/100^2)
    }
    eta[r] ~ dnorm(0, 1/100^2)
    rho[r] ~ dnorm(0, 1/100^2)
  }  
  
  sigmasqinv ~ dgamma(0.0001, 0.0001)
  sigmasq <- 1/sigmasqinv
}
#    ",fill = TRUE)
#sink()

```


## Sample Data

```{r}
fdp <- read.csv("fdpfinal.csv", sep = ',', header = TRUE)

head(fdp)
```



```{r}
fdp['Rank'] = fdp$OffRnk5Wks
fdp['Locality'] = 'Away'
fdp[fdp$Home.Game == 1, 'Locality'] = 'Home'

```


### Simple Ideas



$y|\alpha \sim N(\alpha,\sigma_y^2 I)$

```{r}
mod.classic = lm(FanDuelPts ~ AvgPts5Wks, data = fdp)

plot(FanDuelPts ~ AvgPts5Wks, data = fdp)
```

All over the place, let's add the team defense


`X.defense` is the indicator matrix


** Set up train data **
```{r}
#fdp_train=fdp[fdp$Year == 2015, ]
fdp_train=fdp[fdp$Year == 2015 & fdp$Position=="QB", ]
fdp_train = droplevels(fdp_train)

Num.Opponent = length(unique(fdp_train[, "Opponent"]))
Num.Position = length(unique(fdp_train[, "Position"]))
Num.Rank = length(unique(fdp_train[, "Rank"]))

if (Num.Position == 1) {
  X.defense = model.matrix(~ 0 + Opponent , data=fdp_train)
  X.home = model.matrix(~ 0 + Rank , data=fdp_train)
  X.away = model.matrix(~ 0 + Rank , data=fdp_train)
} else {
  X.defense = model.matrix(~ 0 + Opponent:Position , data=fdp_train)
  X.home = model.matrix(~ 0 + Rank:Position , data=fdp_train)
  X.away = model.matrix(~ 0 + Rank:Position , data=fdp_train)
}

X = cbind(X.defense, X.home, X.away)
```



```{r warning=FALSE, message=FALSE}
library(rjags)
set.seed(20171008)

```

```{r}
# Initialization List for the 4 chains
jags.inits=list(
  list( sigmasqinv=    0.01, 
        .RNG.name = "base::Mersenne-Twister", .RNG.seed = 20171008 ),
  list( sigmasqinv=    0.01, 
        .RNG.name = "base::Mersenne-Twister", .RNG.seed = 20171008 + 1 ),
  list( sigmasqinv=0.000001, 
        .RNG.name = "base::Mersenne-Twister", .RNG.seed = 20171008 + 2 ),
  list( sigmasqinv=0.000001, 
        .RNG.name = "base::Mersenne-Twister", .RNG.seed = 20171008 + 3 )
)

data.jags <- list(
  y= fdp_train$FanDuelPts,
  alpha = fdp_train$AvgPts5Wks,
  X.defense = X.defense,
  X.home = X.home,
  X.away = X.away,
  Num.Position=Num.Position,
  Num.Opponent=Num.Opponent,
  Num.Rank=Num.Rank
)
```



```{r warning=FALSE}
burnAndSample = function(m, N.burnin, N.iter, show.plot, mon.col) {
  update(m, N.burnin) # burn-in
  
  x <- coda.samples(m, mon.col, n.iter=N.iter)
  
  if(show.plot) {
    plot(x, smooth=FALSE)
  }
  
  gelman.R = gelman.diag(x, autoburnin=FALSE, multivariate = FALSE)
  print(gelman.R)
  
  result <- list(
    coda.sam = x, 
    gelman.R.max=max(gelman.R$psrf[, 1])
  )
  
  return(result)
}

```

```{r warning=FALSE}
runModel=TRUE
runSample=TRUE

mon.col <- c("delta", "eta", "rho", "beta.defense", "beta.home", "beta.away", "sigmasq")

NSim = 5000
if (runModel) {
  m <- jags.model("fdp.bug", data.jags, inits = jags.inits, n.chains=4, n.adapt = 1000)
  save(file="fdp.jags.model.Rdata", list="m")
} else {
  load("fdp.jags.model.Rdata")
  m$recompile()
}

load.module("dic")

N.Retry.Loop = 15
if (runSample) {
  N.burnin=2500/2
  for (loopIdx in 1:N.Retry.Loop) {
    (start_time <- Sys.time())
    (N.burnin = N.burnin * 2)
    result = burnAndSample(m, N.burnin, NSim, show.plot=FALSE, mon.col = mon.col)
    (end_time <- Sys.time())
    (result$gelman.R.max)    
  }
  save(file="fdp.jags.samples.Rdata", list="result")
  save(file="fdp.jags.model.Rdata", list="m")
} else {
  load("fdp.jags.samples.Rdata")
  N.burnin=2500/2 * (2**N.Retry.Loop)
}
```

```{r warning=FALSE}
m <- jags.model("fdp.bug", data.jags, inits = jags.inits, n.chains=4, n.adapt = 1000)
load.module("dic")

```

*Run and Check convergence*
```{r fig.width=10,fig.height=11}
N.burnin=2500
result = burnAndSample(m, N.burnin, 5000, show.plot=FALSE, mon.col = mon.col)
```


Not converged as `gelman.R.max` = `r result$gelman.R.max` > 1.1

*Try#2: Double burn in and Re run with `N.burnin`=`r N.burnin * 2`*
```{r fig.width=10,fig.height=11}
N.burnin = N.burnin * 2
result = burnAndSample(m, N.burnin, 5000, show.plot=FALSE, mon.col = mon.col)
```

Not converged as `gelman.R.max` = `r result$gelman.R.max` > 1.1



```{r fig.width=10,fig.height=11}
plot(x, smooth=FALSE)
```



